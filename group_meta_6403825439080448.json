{
    "assignment": {
        "active": false,
        "autograding_enabled": false,
        "autograding_key": "",
        "course": {
            "active": true,
            "created": "2015-01-23 10:36:23.000000",
            "display_name": "CS 61A",
            "id": 5165212546105344,
            "institution": "UC Berkeley",
            "instructor": [],
            "offering": "cal/61A/sp15"
        },
        "created": "2015-02-17 08:04:41.000000",
        "creator": {
            "created": "2015-01-23 09:10:24.000000",
            "email": [
                "sumukh@berkeley.edu"
            ],
            "id": 5644720948641792,
            "is_admin": true
        },
        "display_name": "Maps",
        "due_date": "2015-02-26 22:59:59.000000",
        "id": 6020981852209152,
        "lock_date": "2015-02-28 22:59:59.000000",
        "max_group_size": 2,
        "name": "cal/CS61A/sp15/proj2",
        "points": null,
        "revision": false,
        "templates": "\"{'abstractions.py': '\\\"\\\"\\\"Data Abstractions\\\"\\\"\\\"\\\\n\\\\nfrom utils import mean\\\\n\\\\n# Reviews\\\\n\\\\ndef make_review(restaurant_name, rating):\\\\n    \\\"\\\"\\\"Return a review.\\\"\\\"\\\"\\\\n    return [restaurant_name, rating]\\\\n\\\\ndef review_restaurant_name(review):\\\\n    \\\"\\\"\\\"Return the reviewed restaurant\\\\'s name (string).\\\"\\\"\\\"\\\\n    return review[0]\\\\n\\\\ndef review_rating(review):\\\\n    \\\"\\\"\\\"Return the number of stars given (1 to 5).\\\"\\\"\\\"\\\\n    return review[1]\\\\n\\\\n# Users\\\\n\\\\ndef make_user(name, reviews):\\\\n    \\\"\\\"\\\"Return a user.\\\"\\\"\\\"\\\\n    return [name, {review_restaurant_name(r): r for r in reviews}]\\\\n\\\\ndef user_name(user):\\\\n    \\\"\\\"\\\"Return the USER\\\\'s name (string).\\\"\\\"\\\"\\\\n    return user[0]\\\\n\\\\ndef user_reviews(user):\\\\n    \\\"\\\"\\\"Return a dictionary from restaurant names to reviews by the USER.\\\"\\\"\\\"\\\\n    return user[1]\\\\n\\\\n### === +++ USER ABSTRACTION BARRIER +++ === ###\\\\n\\\\ndef user_reviewed_restaurants(user, restaurants):\\\\n    \\\"\\\"\\\"Return the subset of restaurants reviewed by USER.\\\\n\\\\n    Arguments:\\\\n    user -- a user\\\\n    restaurants -- a dictionary from restaurant names to restaurants\\\\n    \\\"\\\"\\\"\\\\n    names = user_reviews(user).keys()\\\\n    return {name: restaurants[name] for name in names if name in restaurants}\\\\n\\\\ndef user_rating(user, restaurant_name):\\\\n    \\\"\\\"\\\"Return the rating given for RESTAURANT_NAME by USER.\\\"\\\"\\\"\\\\n    return review_rating(user_reviews(user)[restaurant_name])\\\\n\\\\n# Restaurants\\\\n\\\\ndef make_restaurant(name, location, categories, price, reviews):\\\\n    \\\"\\\"\\\"Return a restaurant, implemented as a dictionary.\\\"\\\"\\\"\\\\n    # You may change this starter implementation however you wish, including\\\\n    # adding more items to the dictionary below.\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n    return {\\\\'name\\\\': name,\\\\n            \\\\'location\\\\': location,\\\\n            \\\\'categories\\\\': categories,\\\\n            \\\\'price\\\\': price,\\\\n            }\\\\n\\\\ndef restaurant_name(restaurant):\\\\n    return restaurant[\\\\'name\\\\']\\\\n\\\\ndef restaurant_location(restaurant):\\\\n    return restaurant[\\\\'location\\\\']\\\\n\\\\ndef restaurant_categories(restaurant):\\\\n    return restaurant[\\\\'categories\\\\']\\\\n\\\\ndef restaurant_price(restaurant):\\\\n    return restaurant[\\\\'price\\\\']\\\\n\\\\ndef restaurant_ratings(restaurant):\\\\n    \\\"\\\"\\\"Return a list of ratings (numbers from 1 to 5).\\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\n### === +++ RESTAURANT ABSTRACTION BARRIER +++ === ###\\\\n\\\\ndef restaurant_num_ratings(restaurant):\\\\n    \\\"\\\"\\\"Return the number of ratings for RESTAURANT.\\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef restaurant_mean_rating(restaurant):\\\\n    \\\"\\\"\\\"Return the average rating for RESTAURANT.\\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\n', 'utils.py': '\\\"\\\"\\\"Utilities for Maps\\\"\\\"\\\"\\\\n\\\\nfrom math import sqrt\\\\nfrom random import sample\\\\n\\\\n# Rename the built-in zip (http://docs.python.org/3/library/functions.html#zip)\\\\n_zip = zip\\\\n\\\\ndef map_and_filter(s, map_fn, filter_fn):\\\\n    \\\"\\\"\\\"Return a new list containing the result of calling MAP_FUNC on each\\\\n    element of sequence S for which FILTER_FUNC returns a true value.\\\\n\\\\n    >>> square = lambda x: x * x\\\\n    >>> is_odd = lambda x: x % 2 == 1\\\\n    >>> map_and_filter([1, 2, 3, 4, 5], square, is_odd)\\\\n    [1, 9, 25]\\\\n    \\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n    return [\\\\'REPLACE THIS WITH YOUR LIST COMPREHENSION\\\\']\\\\n\\\\ndef key_of_min_value(d):\\\\n    \\\"\\\"\\\"Returns the key in dict D that corresponds to the minimum value of D.\\\\n\\\\n    >>> letters = {\\\\'a\\\\': 6, \\\\'b\\\\': 5, \\\\'c\\\\': 4, \\\\'d\\\\': 5}\\\\n    >>> min(letters)\\\\n    \\\\'a\\\\'\\\\n    >>> key_of_min_value(letters)\\\\n    \\\\'c\\\\'\\\\n    \\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n    return min(\\\\'REPLACE THIS WITH YOUR SOLUTION\\\\')\\\\n\\\\ndef zip(*sequences):\\\\n    \\\"\\\"\\\"Returns a list of lists, where the i-th list contains the i-th\\\\n    element from each of the argument sequences.\\\\n\\\\n    >>> zip(range(0, 3), range(3, 6))\\\\n    [[0, 3], [1, 4], [2, 5]]\\\\n    >>> for a, b in zip([1, 2, 3], [4, 5, 6]):\\\\n    ...     print(a, b)\\\\n    1 4\\\\n    2 5\\\\n    3 6\\\\n    >>> for triple in zip([\\\\'a\\\\', \\\\'b\\\\', \\\\'c\\\\'], [1, 2, 3], [\\\\'do\\\\', \\\\'re\\\\', \\\\'mi\\\\']):\\\\n    ...     print(triple)\\\\n    [\\\\'a\\\\', 1, \\\\'do\\\\']\\\\n    [\\\\'b\\\\', 2, \\\\'re\\\\']\\\\n    [\\\\'c\\\\', 3, \\\\'mi\\\\']\\\\n    \\\"\\\"\\\"\\\\n    return list(map(list, _zip(*sequences)))\\\\n\\\\ndef enumerate(s, start=0):\\\\n    \\\"\\\"\\\"Returns a list of lists, where the i-th list contains i+start and the\\\\n    i-th element of the sequence.\\\\n\\\\n\\\\n    >>> enumerate([6, 1, \\\\'a\\\\'])\\\\n    [[0, 6], [1, 1], [2, \\\\'a\\\\']]\\\\n    >>> enumerate(\\\\'five\\\\', 5)\\\\n    [[5, \\\\'f\\\\'], [6, \\\\'i\\\\'], [7, \\\\'v\\\\'], [8, \\\\'e\\\\']]\\\\n    \\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef distance(pos1, pos2):\\\\n    \\\"\\\"\\\"Return the Euclidean distance between POS1 and POS2, which are pairs.\\\\n\\\\n    >>> distance([1, 2], [4, 6])\\\\n    5.0\\\\n    \\\"\\\"\\\"\\\\n    return sqrt((pos1[0] - pos2[0]) ** 2 + (pos1[1] - pos2[1]) ** 2)\\\\n\\\\ndef mean(lst):\\\\n    \\\"\\\"\\\"Return the arithmetic mean of a sequence of numbers.\\\\n\\\\n    >>> mean([-1, 3])\\\\n    1.0\\\\n    >>> mean([0, -3, 2, -1])\\\\n    -0.5\\\\n    \\\"\\\"\\\"\\\\n    assert len(lst) > 0, \\\\'cannot find mean of empty sequence\\\\'\\\\n    return sum(lst) / len(lst)\\\\n', 'recommend.py': '\\\"\\\"\\\"A Yelp-powered Restaurant Recommendation Program\\\"\\\"\\\"\\\\n\\\\nfrom abstractions import *\\\\nfrom utils import distance, mean, zip, enumerate, sample\\\\nfrom visualize import draw_map\\\\nfrom data import RESTAURANTS, CATEGORIES, USER_FILES, load_user_file\\\\nfrom ucb import main, trace, interact\\\\n\\\\ndef find_closest(location, centroids):\\\\n    \\\"\\\"\\\"Return the item in CENTROIDS that is closest to LOCATION. If two\\\\n    centroids are equally close, return the first one.\\\\n\\\\n    >>> find_closest([3, 4], [[0, 0], [2, 3], [4, 3], [5, 5]])\\\\n    [2, 3]\\\\n    \\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef group_by_first(pairs):\\\\n    \\\"\\\"\\\"Return a list of pairs that relates each unique key in [key, value]\\\\n    pairs to a list of all values that appear paired with that key.\\\\n\\\\n    Arguments:\\\\n    pairs -- a sequence of pairs\\\\n\\\\n    >>> example = [ [1, 2], [3, 2], [2, 4], [1, 3], [3, 1], [1, 2] ]\\\\n    >>> group_by_first(example)\\\\n    [[2, 3, 2], [2, 1], [4]]\\\\n    \\\"\\\"\\\"\\\\n    # Optional: This implementation is slow because it traverses the list of\\\\n    #           pairs one time for each key. Can you improve it?\\\\n    keys = []\\\\n    for key, _ in pairs:\\\\n        if key not in keys:\\\\n            keys.append(key)\\\\n    return [[y for x, y in pairs if x == key] for key in keys]\\\\n\\\\ndef group_by_centroid(restaurants, centroids):\\\\n    \\\"\\\"\\\"Return a list of lists, where each list contains all restaurants nearest\\\\n    to some item in CENTROIDS. Each item in RESTAURANTS should appear once in\\\\n    the result, along with the other restaurants nearest to the same centroid.\\\\n    No empty lists should appear in the result.\\\\n    \\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef find_centroid(restaurants):\\\\n    \\\"\\\"\\\"Return the centroid of the locations of RESTAURANTS.\\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef k_means(restaurants, k, max_updates=100):\\\\n    \\\"\\\"\\\"Use k-means to group RESTAURANTS by location into K clusters.\\\"\\\"\\\"\\\\n    assert len(restaurants) >= k, \\\\'Not enough restaurants to cluster\\\\'\\\\n    old_centroids, n = [], 0\\\\n    # Select initial centroids randomly by choosing K different restaurants\\\\n    centroids = [restaurant_location(r) for r in sample(restaurants, k)]\\\\n\\\\n    while old_centroids != centroids and n < max_updates:\\\\n        old_centroids = centroids\\\\n        \\\"*** YOUR CODE HERE ***\\\"\\\\n        n += 1\\\\n    return centroids\\\\n\\\\ndef find_predictor(user, restaurants, feature_fn):\\\\n    \\\"\\\"\\\"Return a rating predictor (a function from restaurants to ratings),\\\\n    for USER by performing least-squares linear regression using FEATURE_FN\\\\n    on the items in RESTAURANTS. Also, return the R^2 value of this model.\\\\n\\\\n    Arguments:\\\\n    user -- A user\\\\n    restaurants -- A sequence of restaurants\\\\n    feature_fn -- A function that takes a restaurant and returns a number\\\\n    \\\"\\\"\\\"\\\\n    reviews_by_user = {review_restaurant_name(review): review_rating(review)\\\\n                       for review in user_reviews(user).values()}\\\\n\\\\n    xs = [feature_fn(r) for r in restaurants]\\\\n    ys = [reviews_by_user[restaurant_name(r)] for r in restaurants]\\\\n\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n    b, a, r_squared = 0, 0, 0  # REPLACE THIS LINE WITH YOUR SOLUTION\\\\n\\\\n    def predictor(restaurant):\\\\n        return b * feature_fn(restaurant) + a\\\\n\\\\n    return predictor, r_squared\\\\n\\\\ndef best_predictor(user, restaurants, feature_fns):\\\\n    \\\"\\\"\\\"Find the feature within FEATURE_FNS that gives the highest R^2 value\\\\n    for predicting ratings by the user; return a predictor using that feature.\\\\n\\\\n    Arguments:\\\\n    user -- A user\\\\n    restaurants -- A dictionary from restaurant names to restaurants\\\\n    feature_fns -- A sequence of functions that each takes a restaurant\\\\n    \\\"\\\"\\\"\\\\n    reviewed = list(user_reviewed_restaurants(user, restaurants).values())\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef rate_all(user, restaurants, feature_functions):\\\\n    \\\"\\\"\\\"Return the predicted ratings of RESTAURANTS by USER using the best\\\\n    predictor based a function from FEATURE_FUNCTIONS.\\\\n\\\\n    Arguments:\\\\n    user -- A user\\\\n    restaurants -- A dictionary from restaurant names to restaurants\\\\n    \\\"\\\"\\\"\\\\n    # Use the best predictor for the user, learned from *all* restaurants\\\\n    # (Note: the name RESTAURANTS is bound to a dictionary of all restaurants)\\\\n    predictor = best_predictor(user, RESTAURANTS, feature_functions)\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef search(query, restaurants):\\\\n    \\\"\\\"\\\"Return each restaurant in RESTAURANTS that has QUERY as a category.\\\\n\\\\n    Arguments:\\\\n    query -- A string\\\\n    restaurants -- A sequence of restaurants\\\\n    \\\"\\\"\\\"\\\\n    \\\"*** YOUR CODE HERE ***\\\"\\\\n\\\\ndef feature_set():\\\\n    \\\"\\\"\\\"Return a sequence of feature functions.\\\"\\\"\\\"\\\\n    return [restaurant_mean_rating,\\\\n            restaurant_price,\\\\n            restaurant_num_ratings,\\\\n            lambda r: restaurant_location(r)[0],\\\\n            lambda r: restaurant_location(r)[1]]\\\\n\\\\n@main\\\\ndef main(*args):\\\\n    import argparse\\\\n    parser = argparse.ArgumentParser(\\\\n        description=\\\\'Run Recommendations\\\\',\\\\n        formatter_class=argparse.RawTextHelpFormatter\\\\n    )\\\\n    parser.add_argument(\\\\'-u\\\\', \\\\'--user\\\\', type=str, choices=USER_FILES,\\\\n                        default=\\\\'test_user\\\\',\\\\n                        metavar=\\\\'USER\\\\',\\\\n                        help=\\\\'user file, e.g.\\\\\\\\n\\\\' +\\\\n                        \\\\'{{{}}}\\\\'.format(\\\\',\\\\'.join(sample(USER_FILES, 3))))\\\\n    parser.add_argument(\\\\'-k\\\\', \\\\'--k\\\\', type=int, help=\\\\'for k-means\\\\')\\\\n    parser.add_argument(\\\\'-q\\\\', \\\\'--query\\\\', choices=CATEGORIES,\\\\n                        metavar=\\\\'QUERY\\\\',\\\\n                        help=\\\\'search for restaurants by category e.g.\\\\\\\\n\\\\'\\\\n                        \\\\'{{{}}}\\\\'.format(\\\\',\\\\'.join(sample(CATEGORIES, 3))))\\\\n    parser.add_argument(\\\\'-p\\\\', \\\\'--predict\\\\', action=\\\\'store_true\\\\',\\\\n                        help=\\\\'predict ratings for all restaurants\\\\')\\\\n    args = parser.parse_args()\\\\n\\\\n    # Select restaurants using a category query\\\\n    if args.query:\\\\n        results = search(args.query, RESTAURANTS.values())\\\\n        restaurants = {restaurant_name(r): r for r in results}\\\\n    else:\\\\n        restaurants = RESTAURANTS\\\\n\\\\n    # Load a user\\\\n    assert args.user, \\\\'A --user is required to draw a map\\\\'\\\\n    user = load_user_file(\\\\'{}.dat\\\\'.format(args.user))\\\\n\\\\n    # Collect ratings\\\\n    if args.predict:\\\\n        ratings = rate_all(user, restaurants, feature_set())\\\\n    else:\\\\n        restaurants = user_reviewed_restaurants(user, restaurants)\\\\n        ratings = {name: user_rating(user, name) for name in restaurants}\\\\n\\\\n    # Draw the visualization\\\\n    restaurant_list = list(restaurants.values())\\\\n    if args.k:\\\\n        centroids = k_means(restaurant_list, min(args.k, len(restaurant_list)))\\\\n    else:\\\\n        centroids = [restaurant_location(r) for r in restaurant_list]\\\\n    draw_map(centroids, restaurant_list, ratings)\\\\n'}\"",
        "url": null
    },
    "created": "2015-02-17 15:57:56.651920",
    "id": 6403825439080448,
    "invited": [],
    "member": [
        {
            "created": "2015-01-26 14:41:25.947140",
            "email": [
                "gkhalilieh@berkeley.edu"
            ],
            "id": 5997437890068480,
            "is_admin": false
        },
        {
            "created": "2015-01-27 11:42:46.265510",
            "email": [
                "markchang@berkeley.edu"
            ],
            "id": 5925105003659264,
            "is_admin": false
        }
    ],
    "order": null
}